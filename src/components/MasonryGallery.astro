---
import type { CollectionEntry } from "astro:content";
// import { getImage } from "astro:assets"; // Remove getImage import
import imageDimensionsData from "@/data/image_dimensions.json"; // Import the dimensions JSON using path alias

// Define the expected type for gallery entries
type GalleryEntry = CollectionEntry<"gallery">;

// Define the type for the dimensions data imported from JSON
interface ImageDimensions {
  [key: string]: {
    // Key is the markdown filename (entry.id)
    width: number;
    height: number;
    relativePath: string; // e.g., drone-bts/file.jpg
  };
}

interface Props {
  galleryEntries: GalleryEntry[];
}

const { galleryEntries } = Astro.props;

// Define desired widths for srcset (should match widths generated by the script)
const targetWidths = [400, 800, 1200, 1920];

/**
 * Generates descriptive alt text.
 * @param entry - The gallery collection entry.
 * @param index - Fallback index.
 * @returns Alt text string.
 */
function generateAltText(entry: GalleryEntry, index: number): string {
  if (entry.data.title) return entry.data.title;
  if (entry.data.description)
    return (
      entry.data.description.substring(0, 80) +
      (entry.data.description.length > 80 ? "..." : "")
    );

  // Fallback using entry id (markdown filename)
  const descriptivePart = entry.id
    .replace(/[-_]/g, " ")
    .replace(/\b\w/g, (char) => char.toUpperCase());
  return entry.data.title
    ? entry.data.title
    : `Gallery Image: ${descriptivePart}`;
}

// --- Prepare data for gallery items using pre-optimized images and dimensions JSON ---
const itemsData = galleryEntries
  .map((entry, index) => {
    let itemProps = null; // Initialize to null
    const mdKey = entry.id.replace(/\.md$/, ""); // Use markdown filename (id) without .md extension as the key

    try {
      // Look up image data using the markdown filename key
      const imageData = (imageDimensionsData as ImageDimensions)[mdKey];

      if (
        !imageData ||
        !imageData.width ||
        !imageData.height ||
        !imageData.relativePath
      ) {
        console.error(
          `Skipping gallery entry ${index} (ID: ${mdKey}). Image data not found or incomplete in JSON for key: ${mdKey}`,
        );
        return null;
      }

      const originalWidth = imageData.width;
      const originalHeight = imageData.height;
      const relativePathKey = imageData.relativePath; // e.g., drone-bts/badmintonRAW09896.jpg

      // Determine available widths based on original size
      const availableWidths = targetWidths.filter((w) => w <= originalWidth);
      if (availableWidths.length === 0 && originalWidth > 0) {
        availableWidths.push(originalWidth); // Use original width if smaller than all targets
      } else if (availableWidths.length === 0) {
        availableWidths.push(400); // Fallback if width is 0 or unavailable
      }
      availableWidths.sort((a, b) => a - b); // Ensure widths are sorted ascending

      // Construct paths to optimized images in /public/optimized-images/ using the retrieved relativePathKey
      const filename = relativePathKey.split("/").pop() ?? "";
      const nameWithoutExt = filename.substring(0, filename.lastIndexOf("."));
      const relativeDir = relativePathKey.substring(
        0,
        relativePathKey.lastIndexOf("/"),
      ); // Get the subdirectory
      const optimizedBaseUrl = `/optimized-images/${relativeDir}/${nameWithoutExt}`; // Root-relative URL

      // Build srcset string
      const srcSetValue = availableWidths
        .map((w) => `${optimizedBaseUrl}-w${w}.webp ${w}w`)
        .join(", ");

      // Determine fallback src (smallest available webp)
      const fallbackSrc = `${optimizedBaseUrl}-w${availableWidths[0]}.webp`;

      // Determine largest src for PhotoSwipe (largest available webp)
      const largestSrc = `${optimizedBaseUrl}-w${availableWidths[availableWidths.length - 1]}.webp`;

      const altText = generateAltText(entry, index);

      // --- Assign the properties object if valid ---
      itemProps = {
        src: fallbackSrc,
        srcset: srcSetValue,
        sizes:
          "(max-width: 639px) 100vw, (max-width: 767px) 50vw, (max-width: 1023px) 33vw, 25vw", // Define sizes attribute
        altText,
        largestSrc: largestSrc, // Use the determined largest source URL
        originalWidth: originalWidth,
        originalHeight: originalHeight,
      };
    } catch (error) {
      console.error(
        `Error processing gallery entry ${index} (ID: ${entry.id}):`,
        error,
      );
      // itemProps remains null
    }

    return itemProps; // Return the props object or null
  })
  .filter(
    (item): item is NonNullable<typeof item> => item !== null, // Filter out nulls from errors
  );
---
{/* Masonry Grid Container */}
<div class="columns-1 gap-4 space-y-4 sm:columns-2 md:columns-3 lg:columns-4 pswp-gallery">
  {itemsData.map(item => (
    <div class="break-inside-avoid overflow-hidden rounded-lg shadow-md">
      <a
        href={item.largestSrc}
        data-pswp-src={item.largestSrc}
        data-pswp-width={item.originalWidth}
        data-pswp-height={item.originalHeight}
        target="_blank"
        rel="noreferrer"
        aria-label={`View image: ${item.altText}`}
        class="block group"
      >
        <img
          src={item.src}
          srcset={item.srcset}
          sizes={item.sizes}
          alt={item.altText}
          loading="lazy"
          decoding="async"
          class="block h-auto w-full object-cover transition duration-300 ease-in-out group-hover:scale-105 group-hover:opacity-80"
          width={item.originalWidth}
          height={item.originalHeight}
        />
      </a>
    </div>
  ))}
</div>

{/* PhotoSwipe Initialization Script */}
<script is:inline>
  import PhotoSwipeLightbox from 'photoswipe/lightbox';
  import 'photoswipe/style.css'; // Import base PhotoSwipe styles

  // Initialize PhotoSwipe only once the component is visible
  try {
    const lightbox = new PhotoSwipeLightbox({
      gallery: '.pswp-gallery', // Target the container div
      children: 'a',          // Target the anchor tags within the container
      pswpModule: () => import('photoswipe'), // Dynamically import the core PhotoSwipe module
    });

    // Add event listeners if needed (e.g., for error handling)
    lightbox.on('error', (error) => {
      console.error('PhotoSwipe Error:', error);
    });
    lightbox.on('loadError', (event) => {
      console.error('PhotoSwipe Image Load Error:', event);
    });

    // Initialize the lightbox after a minimal delay to ensure DOM is ready
    setTimeout(() => {
        try {
            lightbox.init();
            // console.log('PhotoSwipe initialized with setTimeout'); // Optional logging
        } catch (initError) {
            console.error("Error during PhotoSwipe init:", initError);
        }
    }, 0); // Delay of 0 pushes execution after current stack

  } catch (error) {
    console.error("Error setting up PhotoSwipe:", error);
  }
</script>

<style>
  /* Optional: Add custom styles or overrides for PhotoSwipe if needed */
</style>

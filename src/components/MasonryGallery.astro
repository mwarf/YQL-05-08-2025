---
import type { CollectionEntry } from "astro:content";
import { getImage } from "astro:assets"; // Import getImage

// Define the expected type for gallery entries
type GalleryEntry = CollectionEntry<"gallery">;

interface Props {
  galleryEntries: GalleryEntry[];
}

const { galleryEntries } = Astro.props;

// Define desired widths for srcset
const targetWidths = [400, 800, 1200, 1920];

/**
 * Generates descriptive alt text.
 * @param entry - The gallery collection entry.
 * @param index - Fallback index.
 * @returns Alt text string.
 */
function generateAltText(entry: GalleryEntry, index: number): string {
  if (entry.data.title) return entry.data.title;
  if (entry.data.description)
    return (
      entry.data.description.substring(0, 80) +
      (entry.data.description.length > 80 ? "..." : "")
    );

  // Fallback using filename (safer extraction)
  const srcString = entry.data.image?.src;
  if (typeof srcString === 'string') {
    const filename = srcString.split("/").pop()?.split("?")[0] ?? '';
    if (filename) {
        const nameWithoutExt = filename.substring(0, filename.lastIndexOf('.')) || filename;
        const descriptivePart = nameWithoutExt
            .replace(/[-_]/g, " ")
            .replace(/\b\w/g, (char) => char.toUpperCase());
        return `BTS Drone Photo ${index + 1} - ${descriptivePart}`;
    }
  }
  return `BTS Drone Photo ${index + 1}`;
}

// --- Prepare data for gallery items using getImage ---
const itemsDataPromises = galleryEntries.map(async (entry, index) => {
  let itemProps = null; // Initialize to null

  try {
    // --- Use getImage to generate optimized image attributes ---
    const imageMetadata = entry.data.image; // Image metadata from content collection

    if (!imageMetadata || typeof imageMetadata !== 'object' || !('src' in imageMetadata)) {
        console.error(`Skipping image ${index} due to missing or invalid image metadata.`);
        return null;
    }

    // Filter target widths to not exceed original image width
    const availableWidths = targetWidths.filter(w => w <= imageMetadata.width);
     if (availableWidths.length === 0 && imageMetadata.width > 0) {
        availableWidths.push(imageMetadata.width); // Use original width if smaller than all targets
    } else if (availableWidths.length === 0) {
        availableWidths.push(400); // Fallback if width is 0 or unavailable
    }

    // Get optimized image info using getImage
    const optimizedImage = await getImage({
      src: imageMetadata, // Pass the metadata object directly
      widths: availableWidths,
      formats: ["webp", "avif"], // Request modern formats
      // You might need to specify quality or other options here
    });

    // Get the largest available source for PhotoSwipe (prefer webp)
    // Find the largest width entry in the generated srcset
    const srcSetValue = optimizedImage.attributes.srcset?.toString() ?? '';
    const largestSrcEntry = srcSetValue.split(', ').reduce((largest: string, current: string) => {
        const currentWidth = parseInt(current.split(' ')[1]?.replace('w', '') || '0');
        const largestWidth = parseInt(largest.split(' ')[1]?.replace('w', '') || '0');
        return currentWidth > largestWidth ? current : largest;
    }, srcSetValue.split(', ')[0] || optimizedImage.src); // Fallback to first or src

    const largestSrc = largestSrcEntry.split(' ')[0]; // Extract URL

    const altText = generateAltText(entry, index);

    // --- Assign the properties object if valid ---
    itemProps = {
      src: optimizedImage.src, // Fallback src
      srcset: srcSetValue, // Use generated srcset string
      sizes: "(max-width: 639px) 100vw, (max-width: 767px) 50vw, (max-width: 1023px) 33vw, 25vw", // Define sizes attribute
      altText,
      largestSrc: largestSrc, // Use the determined largest source
      originalWidth: imageMetadata.width,
      originalHeight: imageMetadata.height,
    };

  } catch (error) {
    console.error(`Error processing gallery entry ${index} (ID: ${entry.id}):`, error);
    // itemProps remains null
  }

  return itemProps; // Return the props object or null
});

// Resolve all promises and filter out nulls
const itemsData = (await Promise.all(itemsDataPromises))
    .filter((item): item is NonNullable<typeof item> => item !== null);
---
{/* Masonry Grid Container */}
<div class="columns-1 gap-4 space-y-4 sm:columns-2 md:columns-3 lg:columns-4 pswp-gallery">
  {itemsData.map(item => (
    <div class="break-inside-avoid overflow-hidden rounded-lg shadow-md">
      <a
        href={item.largestSrc}
        data-pswp-src={item.largestSrc}
        data-pswp-width={item.originalWidth}
        data-pswp-height={item.originalHeight}
        target="_blank"
        rel="noreferrer"
        aria-label={`View image: ${item.altText}`}
        class="block group"
      >
        <img
          src={item.src}
          srcset={item.srcset}
          sizes={item.sizes}
          alt={item.altText}
          loading="lazy"
          decoding="async"
          class="block h-auto w-full object-cover transition duration-300 ease-in-out group-hover:scale-105 group-hover:opacity-80"
          width={item.originalWidth}
          height={item.originalHeight}
        />
      </a>
    </div>
  ))}
</div>

{/* PhotoSwipe Initialization Script */}
<script is:inline>
  import PhotoSwipeLightbox from 'photoswipe/lightbox';
  import 'photoswipe/style.css'; // Import base PhotoSwipe styles

  // Initialize PhotoSwipe only once the component is visible
  try {
    const lightbox = new PhotoSwipeLightbox({
      gallery: '.pswp-gallery', // Target the container div
      children: 'a',          // Target the anchor tags within the container
      pswpModule: () => import('photoswipe'), // Dynamically import the core PhotoSwipe module
    });

    // Add event listeners if needed (e.g., for error handling)
    lightbox.on('error', (error) => {
      console.error('PhotoSwipe Error:', error);
    });
    lightbox.on('loadError', (event) => {
      console.error('PhotoSwipe Image Load Error:', event);
    });

    // Initialize the lightbox after a minimal delay to ensure DOM is ready
    setTimeout(() => {
        try {
            lightbox.init();
            // console.log('PhotoSwipe initialized with setTimeout'); // Optional logging
        } catch (initError) {
            console.error("Error during PhotoSwipe init:", initError);
        }
    }, 0); // Delay of 0 pushes execution after current stack

  } catch (error) {
    console.error("Error setting up PhotoSwipe:", error);
  }
</script>

<style>
  /* Optional: Add custom styles or overrides for PhotoSwipe if needed */
</style>

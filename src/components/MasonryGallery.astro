---
import type { CollectionEntry } from 'astro:content';
import path from 'node:path'; 

// Define the expected type for gallery entries
type GalleryEntry = CollectionEntry<'gallery'>;

interface Props {
  galleryEntries: GalleryEntry[];
}

const { galleryEntries } = Astro.props;

// Define the widths generated by the optimization script
const targetWidths = [400, 800, 1200, 1920]; 

/**
 * Constructs the base public path for optimized images.
 * @param sourceImagePath - Path from the content collection.
 * @returns Base path like /optimized-images/subdir/filename (no size/extension) or null.
 */
function getOptimizedBasePath(sourceImagePath: string | undefined): string | null {
  if (!sourceImagePath) {
    console.error("getOptimizedBasePath received undefined sourceImagePath");
    return null;
  }

  let relativeToSrcImages: string | null = null; 

  const srcImagesMarker = '/src/images/';
  const srcImagesIndex = sourceImagePath.indexOf(srcImagesMarker);

  if (srcImagesIndex !== -1) {
    relativeToSrcImages = sourceImagePath.substring(srcImagesIndex + srcImagesMarker.length);
    relativeToSrcImages = relativeToSrcImages.split('?')[0]; 
  } else {
     try {
       relativeToSrcImages = path.relative('../../images', sourceImagePath); 
     } catch (e) {
       console.error(`[Fallback Path Processing] Failed path.relative calculation for: ${sourceImagePath}`, e);
       relativeToSrcImages = null;
     }
  }

  if (!relativeToSrcImages || relativeToSrcImages.startsWith('..')) {
      console.error(`[Path Check Failed] Invalid relative path derived. Original: ${sourceImagePath}, Derived: ${relativeToSrcImages}`);
      return null; 
  }

  try {
    const ext = path.extname(relativeToSrcImages);
    const pathWithoutExt = relativeToSrcImages.replace(ext, '');
    const basePath = `/optimized-images/${pathWithoutExt}`;
    return basePath;
  } catch (e) {
    console.error(`[Base Path Construction Error] Failed for relative path: ${relativeToSrcImages}`, e);
    return null;
  }
}

/**
 * Generates descriptive alt text.
 * @param entry - The gallery collection entry.
 * @param index - Fallback index.
 * @returns Alt text string.
 */
function generateAltText(entry: GalleryEntry, index: number): string {
    if (entry.data.title) return entry.data.title; 
    if (entry.data.description) return entry.data.description.substring(0, 80) + (entry.data.description.length > 80 ? '...' : '');
    
    const filename = entry.data.image.src.split('/').pop();
    if (filename) {
        const nameWithoutExt = filename.replace(path.extname(filename), '');
        const descriptivePart = nameWithoutExt.replace(/[-_]/g, ' ').replace(/\b\w/g, char => char.toUpperCase()); 
        return `BTS Drone Photo ${index + 1} - ${descriptivePart}`;
    }
    return `BTS Drone Photo ${index + 1}`; 
}

// --- Prepare data for gallery items in the script section ---
const itemsData = galleryEntries.map((entry, index) => {
  let itemProps = null; // Initialize to null

  try {
    // --- Calculate image attributes ---
    const sourcePath = entry.data.image.src;
    const optimizedBasePath = getOptimizedBasePath(sourcePath);
    const originalWidth = entry.data.image.width;
    const originalHeight = entry.data.image.height;

    // Only proceed if we have a valid base path
    if (optimizedBasePath) {
      const availableWidths = targetWidths.filter(w => w <= originalWidth);
      if (availableWidths.length === 0) {
          availableWidths.push(originalWidth > 0 ? originalWidth : targetWidths[0]);
      }

      const srcset = availableWidths
        .map(w => `${optimizedBasePath}-w${w}.webp ${w}w`)
        .join(', ');

      const sizes = "(max-width: 639px) 100vw, (max-width: 767px) 50vw, (max-width: 1023px) 33vw, 25vw";

      const defaultWidth = availableWidths[0];
      const defaultSrc = `${optimizedBasePath}-w${defaultWidth}.webp`;

      const largestWidth = availableWidths[availableWidths.length - 1];
      const largestSrc = `${optimizedBasePath}-w${largestWidth}.webp`;

      const altText = generateAltText(entry, index);

      // --- Assign the properties object if valid ---
      itemProps = {
        defaultSrc,
        srcset,
        sizes,
        altText,
        largestSrc,
        originalWidth,
        originalHeight,
      };

    } else {
       console.error(`Skipping image ${index} due to invalid base path.`);
       // itemProps remains null
    }
  } catch (error) {
    console.error(`Error processing gallery entry ${index}:`, error);
    // itemProps remains null
  }

  return itemProps; // Return the props object or null
}).filter((item): item is NonNullable<typeof item> => item !== null); // Filter out null items and assert type
---
{/* Masonry Grid Container */}
<div class="columns-1 gap-4 space-y-4 sm:columns-2 md:columns-3 lg:columns-4 pswp-gallery">
  {itemsData.map(item => (
    <div class="break-inside-avoid overflow-hidden rounded-lg shadow-md">
      <a
        href={item.largestSrc}
        data-pswp-src={item.largestSrc}
        data-pswp-width={item.originalWidth}
        data-pswp-height={item.originalHeight}
        target="_blank"
        rel="noreferrer"
        aria-label={`View image: ${item.altText}`}
        class="block group"
      >
        <img
          src={item.defaultSrc}
          srcset={item.srcset}
          sizes={item.sizes}
          alt={item.altText}
          loading="lazy"
          decoding="async"
          class="block h-auto w-full object-cover transition duration-300 ease-in-out group-hover:scale-105 group-hover:opacity-80"
          width={item.originalWidth}
          height={item.originalHeight}
        />
      </a>
    </div>
  ))}
</div>

{/* PhotoSwipe Initialization Script */}
<script is:inline>
  import PhotoSwipeLightbox from 'photoswipe/lightbox';
  import 'photoswipe/style.css'; // Import base PhotoSwipe styles

  // Initialize PhotoSwipe only once the component is visible
  try {
    const lightbox = new PhotoSwipeLightbox({
      gallery: '.pswp-gallery', // Target the container div
      children: 'a',          // Target the anchor tags within the container
      pswpModule: () => import('photoswipe'), // Dynamically import the core PhotoSwipe module
    });

    // Add event listeners if needed (e.g., for error handling)
    lightbox.on('error', (error) => {
      console.error('PhotoSwipe Error:', error);
    });
    lightbox.on('loadError', (event) => {
      console.error('PhotoSwipe Image Load Error:', event);
    });

    // Initialize the lightbox after a minimal delay to ensure DOM is ready
    setTimeout(() => {
        try {
            lightbox.init();
            console.log('PhotoSwipe initialized with setTimeout');
        } catch (initError) {
            console.error("Error during PhotoSwipe init:", initError);
        }
    }, 0); // Delay of 0 pushes execution after current stack

  } catch (error) {
    console.error("Error setting up PhotoSwipe:", error);
  }
</script>

<style>
  /* Optional: Add custom styles or overrides for PhotoSwipe if needed */
</style>
